<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>DCC Speed Tools - Live Measurements</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  </head>
  <body>
    <main class="app">
      <header class="header">
        <div class="header-content">
          <p class="eyebrow">Trackside Telemetry</p>
          <h1>DCC Speed Tools</h1>
          <p class="subtitle">
            Live transit measurements with error bands from the serial stream.
          </p>
        </div>
        <div class="header-side">
          <a class="link-button settings-button" href="{{ url_for('settings') }}">Settings</a>
          <div class="meta">
            <div>
              <span class="meta-label">Serial</span>
              <span class="meta-value">{{ serial_port or 'Not detected' }}</span>
            </div>
            <div>
              <span class="meta-label">Baud</span>
              <span class="meta-value">{{ baud }}</span>
            </div>
            <div>
              <span class="meta-label">Version</span>
              <span class="meta-value" id="version-value">{{ version or 'Pending' }}</span>
            </div>
          </div>
        </div>
      </header>

      <section class="panel live-status">
        <div class="panel-header">
          <div>
            <h2>Live Status</h2>
            <p class="panel-subtitle">
              Real-time sensor state, direction, and the last speed band.
            </p>
          </div>
          <div class="status" id="live-status-summary">Waiting for sensor data...</div>
        </div>
        <div class="status-grid">
          <div class="sensor-diagram">
            <svg class="sensor-svg" viewBox="0 0 280 100" role="img" aria-label="Sensor state">
              <g class="track">
                <rect x="20" y="44" width="240" height="12" rx="6"></rect>
              </g>
              <circle id="sensor-1-light" class="sensor-light" cx="50" cy="50" r="18"></circle>
              <circle id="sensor-2-light" class="sensor-light" cx="230" cy="50" r="18"></circle>
              <g id="direction-arrow" class="direction-arrow">
                <path d="M80 50 H200"></path>
                <path d="M200 50 L188 40"></path>
                <path d="M200 50 L188 60"></path>
              </g>
            </svg>
            <div class="sensor-labels">
              <span>Sensor 0</span>
              <span>Sensor 1</span>
            </div>
          </div>
          <div class="status-details">
            <div class="detail">
              <span class="meta-label">Sensor 0</span>
              <span class="detail-value" id="sensor-1-state">--</span>
            </div>
            <div class="detail">
              <span class="meta-label">Sensor 1</span>
              <span class="detail-value" id="sensor-2-state">--</span>
            </div>
            <div class="detail">
              <span class="meta-label">State</span>
              <span class="detail-value" id="sensor-state-label">--</span>
            </div>
            <div class="detail">
              <span class="meta-label">Expected</span>
              <span class="detail-value" id="expected-direction">--</span>
            </div>
            <div class="detail reading hidden" id="speed-band-wrap">
              <span class="meta-label">Last Reading</span>
              <span class="detail-value" id="speed-band">--</span>
            </div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-header">
          <div>
            <h2>Recent Measurements</h2>
          </div>
          <div class="status" id="status">Waiting for data...</div>
        </div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Received</th>
                <th>Speed</th>
                <th>Error</th>
                <th>Error Band</th>
                <th>OK</th>
                <th>Sensors</th>
                <th>Delta Time</th>
              </tr>
            </thead>
            <tbody id="measurements-body">
              <tr>
                <td colspan="7" class="empty">No measurements yet.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </main>

    <script>
      const body = document.getElementById("measurements-body");
      const status = document.getElementById("status");
      const versionValue = document.getElementById("version-value");
      const liveStatusSummary = document.getElementById("live-status-summary");
      const sensorStateLabel = document.getElementById("sensor-state-label");
      const expectedDirection = document.getElementById("expected-direction");
      const sensor1State = document.getElementById("sensor-1-state");
      const sensor2State = document.getElementById("sensor-2-state");
      const speedBandWrap = document.getElementById("speed-band-wrap");
      const speedBand = document.getElementById("speed-band");
      const sensor1Light = document.getElementById("sensor-1-light");
      const sensor2Light = document.getElementById("sensor-2-light");
      const directionArrow = document.getElementById("direction-arrow");
      const numberFormat = new Intl.NumberFormat(undefined, {
        maximumFractionDigits: 3,
      });

      function formatNumber(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        return numberFormat.format(value);
      }

      function formatBand(low, high, unit) {
        if (low === null || high === null || low === undefined || high === undefined) {
          return "-";
        }
        const suffix = unit ? ` ${unit}` : "";
        return `${formatNumber(low)}${suffix} to ${formatNumber(high)}${suffix}`;
      }

      function formatPercent(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        return `${formatNumber(value)}%`;
      }

      function formatSpeed(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        return `${formatNumber(value)} MPH`;
      }

      function formatBandValue(low, high) {
        if (low === null || high === null || low === undefined || high === undefined) {
          return "-";
        }
        return `${formatNumber(low)} to ${formatNumber(high)} MPH`;
      }

      function formatMs(value) {
        if (value === null || value === undefined) {
          return "-";
        }
        const ms = value / 1000;
        return `${ms.toFixed(3)} ms`;
      }

      function formatSensors(start, end) {
        if (start === null || end === null || start === undefined || end === undefined) {
          return "-";
        }
        return `${start} -> ${end}`;
      }

      function rowHtml(measurement) {
        const okValue = measurement.ok;
        const okLabel = okValue === null || okValue === undefined
          ? "-"
          : (okValue ? "OK" : "Out");
        const okClass = okValue === null || okValue === undefined
          ? "neutral"
          : (okValue ? "ok" : "bad");

        return `
          <tr>
            <td>${measurement.received_iso || "-"}</td>
            <td>${formatSpeed(measurement.mph)}</td>
            <td>${formatPercent(measurement.err)}</td>
            <td>${formatBand(measurement.err_low, measurement.err_high, "MPH")}</td>
            <td class="${okClass}">${okLabel}</td>
            <td>${formatSensors(measurement.start_sensor, measurement.end_sensor)}</td>
            <td>${formatMs(measurement.dt_us)}</td>
          </tr>
        `;
      }

      function render(measurements) {
        if (!measurements || measurements.length === 0) {
          status.textContent = "No measurements yet.";
          body.innerHTML = '<tr><td colspan="7" class="empty">No measurements yet.</td></tr>';
          return;
        }

        status.textContent = `Showing ${measurements.length} most recent passes.`;
        body.innerHTML = measurements.map(rowHtml).join("");
      }

      function setLiveStatusSummary(message, tone) {
        if (!liveStatusSummary) {
          return;
        }
        liveStatusSummary.textContent = message;
        if (tone) {
          liveStatusSummary.dataset.tone = tone;
        } else {
          liveStatusSummary.removeAttribute("data-tone");
        }
      }

      function describeSensor(active) {
        if (active === true) {
          return "Blocked";
        }
        if (active === false) {
          return "Clear";
        }
        return "Unknown";
      }

      function setLightState(light, active) {
        if (!light) {
          return;
        }
        light.classList.toggle("active", active === true);
        light.classList.toggle("inactive", active === false);
        light.classList.toggle("unknown", active !== true && active !== false);
      }

      function resolveExpectedDirection(state) {
        if (state.expected_direction) {
          return state.expected_direction;
        }
        if (state.expected_sensor === 1) {
          return "0->1";
        }
        if (state.expected_sensor === 0) {
          return "1->0";
        }
        return null;
      }

      function updateArrow(state) {
        if (!directionArrow) {
          return;
        }
        const waiting =
          state.waiting === true ||
          (state.state && state.state.toLowerCase().includes("wait"));
        const direction = resolveExpectedDirection(state);
        directionArrow.classList.toggle("active", Boolean(direction && waiting));
        directionArrow.classList.toggle("reverse", direction === "1->0");
      }

      function updateSpeedBand(state) {
        if (!speedBandWrap || !speedBand) {
          return;
        }
        const measurement = state.last_measurement;
        const finishing = state.finishing === true;
        const hasBand = measurement && measurement.err_low !== null && measurement.err_high !== null;
        if (!hasBand || !finishing) {
          speedBandWrap.classList.add("hidden");
          return;
        }

        speedBand.textContent = formatBandValue(
          measurement.err_low,
          measurement.err_high
        );
        speedBand.classList.toggle("ok", measurement.ok === true);
        speedBand.classList.toggle("bad", measurement.ok === false);
        speedBandWrap.classList.remove("hidden");
      }

      function renderState(state) {
        if (!state) {
          setLiveStatusSummary("Waiting for sensor data...");
          return;
        }
        const derivedState = state.state || "Awaiting sensor state";
        setLiveStatusSummary(derivedState);

        if (sensorStateLabel) {
          sensorStateLabel.textContent = derivedState;
        }
        if (sensor1State) {
          sensor1State.textContent = describeSensor(state.sensor_1_active);
        }
        if (sensor2State) {
          sensor2State.textContent = describeSensor(state.sensor_2_active);
        }
        if (expectedDirection) {
          const direction = resolveExpectedDirection(state);
          const waiting =
            state.waiting === true ||
            (state.state && state.state.toLowerCase().includes("wait"));
          if (!waiting || !direction) {
            expectedDirection.textContent = "--";
          } else if (direction === "0->1") {
            expectedDirection.textContent = "Sensor 1";
          } else if (direction === "1->0") {
            expectedDirection.textContent = "Sensor 0";
          } else {
            expectedDirection.textContent = "--";
          }
        }

        setLightState(sensor1Light, state.sensor_1_active);
        setLightState(sensor2Light, state.sensor_2_active);
        updateArrow(state);
        updateSpeedBand(state);
      }

      async function fetchMeasurements() {
        try {
          const response = await fetch("/api/measurements");
          if (!response.ok) {
            throw new Error("Bad response");
          }
          const payload = await response.json();
          render(payload.measurements);
          if (versionValue) {
            versionValue.textContent = payload.version || "Pending";
          }
        } catch (err) {
          status.textContent = "Connection error";
        }
      }

      async function fetchState() {
        try {
          const response = await fetch("/api/state");
          if (!response.ok) {
            throw new Error("Bad response");
          }
          const payload = await response.json();
          renderState(payload);
        } catch (err) {
          setLiveStatusSummary("Sensor status unavailable", "warn");
        }
      }

      function poll() {
        fetchMeasurements();
        fetchState();
      }

      poll();
      setInterval(poll, 1500);
    </script>
  </body>
</html>
